using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LightMock.Generator
{
    sealed class AbstractClassProcessor : ClassProcessor
    {
        private readonly ClassDeclarationSyntax candidateClass;
        private readonly INamedTypeSymbol baseClass;
        private readonly ProtectedMemberSymbolVisitor protectedVisitor;
        private readonly string nameSpace;
        private readonly AbstractClassSymbolVisitor symbolVisitor;
        private readonly string baseName;
        private readonly string interfaceName;
        private readonly string typeArgumentsWithBrackets;
        private readonly string typeArgumentsWithComma;
        private readonly string whereClause;
        private readonly string commaArguments;
        private readonly List<string> constructors;
        private readonly List<string> constructorsCall;

        public AbstractClassProcessor(
            ClassDeclarationSyntax candidateClass,
            INamedTypeSymbol typeSymbol,
            INamedTypeSymbol baseClass) : base(typeSymbol)
        {
            this.candidateClass = candidateClass;
            this.baseClass = baseClass;
            this.protectedVisitor = new ProtectedMemberSymbolVisitor();
            this.nameSpace = typeSymbol.ContainingNamespace.ToDisplayString(KNamespaceDisplayFormat);
            this.symbolVisitor = new AbstractClassSymbolVisitor(nameSpace);
            this.baseName = baseClass.Accept(symbolVisitor);
            this.interfaceName = Prefix.ProtectedToPublicInterface + baseClass.Name;

            var withTypeParams = typeSymbol.ToDisplayString(KWithTypeParams);
            var withWhereClause = typeSymbol.ToDisplayString(KWithWhereClause);
            var typeArguments = withTypeParams.Replace(typeSymbol.ToDisplayString(KNamespaceDisplayFormat), "");

            this.typeArgumentsWithBrackets = typeArguments.Length > 0 ? typeArguments : "";
            this.typeArgumentsWithComma = typeArguments.Length > 0 ? typeArguments.Trim('<', '>') + ", " : "";
            this.whereClause = withWhereClause.Replace(withTypeParams, "");
            this.commaArguments = string.Join(",", typeSymbol.OriginalDefinition.TypeArguments.Select(i => " "));
            this.constructors = new List<string>(
                baseClass.Constructors.Select(
                    (IMethodSymbol i) => i.ToDisplayString(KConstructorFormat).Replace(baseClass.Name, "").Trim('(', ')')));
            this.constructorsCall = new List<string>(
                baseClass.Constructors.Select(
                    (IMethodSymbol i) => i.ToDisplayString(KConstructorCallFormat).Replace(baseClass.Name, "").Trim('(', ')')));
        }

        string GenerateConstructor(string declaration, string call)
        {
            return $@"
        public {typeSymbol.Name}(IInvocationContext<{baseName}> {VariableNames.Context}, IInvocationContext<{interfaceName}{typeArgumentsWithBrackets}> {VariableNames.ProtectedContext}, {declaration})
            : base({call})
        {{
            this.{VariableNames.Context} = {VariableNames.Context};
            this.{VariableNames.ProtectedContext} = {VariableNames.ProtectedContext};
        }}
";
        }

        string GenerateDefaultConstructor()
        {
            return $@"
        public {typeSymbol.Name}(IInvocationContext<{baseName}> {VariableNames.Context}, IInvocationContext<{interfaceName}{typeArgumentsWithBrackets}> {VariableNames.ProtectedContext})
        {{
            this.{VariableNames.Context} = {VariableNames.Context};
            this.{VariableNames.ProtectedContext} = {VariableNames.ProtectedContext};
        }}
";
        }

        IEnumerable<string> GenerateConstructors()
        {
            for (int i = 0; i < constructors.Count; i++)
            {
                yield return constructors[i].Length == 0
                    ? GenerateDefaultConstructor()
                    : GenerateConstructor(constructors[i], constructorsCall[i]);
            }
        }

        public override SourceText DoGenerate()
        {
            var members = baseClass.GetMembers();
            var code = $@"// <auto-generated />
using LightMock;

namespace {nameSpace}
{{
    public interface {interfaceName}{typeArgumentsWithBrackets}
        {whereClause}
    {{
        {string.Join("\r\n        ", members.Select(i => i.Accept(protectedVisitor)).SkipWhile(i => string.IsNullOrWhiteSpace(i)))}
    }}


    partial class {typeSymbol.Name}{typeArgumentsWithBrackets} : {baseClass}, {interfaceName}{typeArgumentsWithBrackets}
        {whereClause}
    {{
        private readonly IInvocationContext<{baseName}> {VariableNames.Context};
        private readonly IInvocationContext<{interfaceName}{typeArgumentsWithBrackets}> {VariableNames.ProtectedContext};

{string.Join("\r\n", GenerateConstructors())}

        {string.Join("\r\n        ", members.Select(i => i.Accept(symbolVisitor)).SkipWhile(i => string.IsNullOrWhiteSpace(i)))}
    }}
}}
";
            return SourceText.From(code, Encoding.UTF8);
        }

        public override IEnumerable<Diagnostic> GetErrors() => Enumerable.Empty<Diagnostic>();

        public override IEnumerable<Diagnostic> GetWarnings()
        {
            if (typeSymbol.Interfaces.Length > 0)
            {
                yield return Diagnostic.Create(
                    DiagnosticsDescriptors.KTooManyInterfacesWarningDescriptor,
                    Location.Create(candidateClass.SyntaxTree, new TextSpan()),
                    typeSymbol.Name);
            }
        }


        static readonly SymbolDisplayFormat KConstructorFormat =
            new SymbolDisplayFormat(
                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                memberOptions:
                    SymbolDisplayMemberOptions.IncludeParameters |
                    SymbolDisplayMemberOptions.IncludeType |
                    SymbolDisplayMemberOptions.IncludeRef,
                kindOptions:
                    SymbolDisplayKindOptions.IncludeMemberKeyword,
                parameterOptions:
                    SymbolDisplayParameterOptions.IncludeName |
                    SymbolDisplayParameterOptions.IncludeType |
                    SymbolDisplayParameterOptions.IncludeParamsRefOut |
                    SymbolDisplayParameterOptions.IncludeDefaultValue,
                localOptions: SymbolDisplayLocalOptions.IncludeType,
                miscellaneousOptions:
                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |
                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes |
                    SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

        static readonly SymbolDisplayFormat KConstructorCallFormat =
            new SymbolDisplayFormat(
                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                memberOptions:
                    SymbolDisplayMemberOptions.IncludeParameters |
                    SymbolDisplayMemberOptions.IncludeType |
                    SymbolDisplayMemberOptions.IncludeRef,
                kindOptions:
                    SymbolDisplayKindOptions.IncludeMemberKeyword,
                parameterOptions:
                    SymbolDisplayParameterOptions.IncludeName |
                    SymbolDisplayParameterOptions.IncludeParamsRefOut |
                    SymbolDisplayParameterOptions.IncludeDefaultValue,
                localOptions: SymbolDisplayLocalOptions.IncludeType,
                miscellaneousOptions:
                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |
                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes |
                    SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);
    }
}
