using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LightMock.Generator
{
    sealed class MockAbstractClassProcessor : ClassProcessor
    {
        private readonly ProtectedMemberSymbolVisitor protectedVisitor;
        private readonly string @namespace;
        private readonly AbstractClassSymbolVisitor symbolVisitor;
        private readonly string baseName;
        private readonly string className;
        private readonly string interfaceName;

        public MockAbstractClassProcessor(
            INamedTypeSymbol typeSymbol) : base(typeSymbol)
        {
            this.protectedVisitor = new ProtectedMemberSymbolVisitor();
            this.@namespace = typeSymbol.ContainingNamespace.ToDisplayString(KNamespaceDisplayFormat);
            this.symbolVisitor = new AbstractClassSymbolVisitor(@namespace);
            this.baseName = typeSymbol.Accept(symbolVisitor);
            this.className = Prefix.MockClass + (typeSymbol.IsGenericType
                ? typeSymbol.Name + "<" + string.Join(",", typeSymbol.TypeParameters.Select(i => i.Name)) + ">"
                : typeSymbol.Name);
            this.interfaceName = Prefix.ProtectedToPublicInterface + (typeSymbol.IsGenericType
                ? typeSymbol.Name + "<" + string.Join(",", typeSymbol.TypeParameters.Select(i => i.Name)) + ">"
                : typeSymbol.Name);
        }

        public override SourceText DoGenerate()
        {
            var members = typeSymbol.GetMembers();
            var code = $@"// <auto-generated />
using LightMock;
using System;
using System.Diagnostics;
using System.Linq.Expressions;

namespace {@namespace}
{{
    public interface {interfaceName}
    {{
        {string.Join("\r\n        ", members.Select(i => i.Accept(protectedVisitor)).SkipWhile(i => string.IsNullOrWhiteSpace(i)))}
    }}


    partial class {className} : {baseName}, {interfaceName}
    {{
        private readonly IInvocationContext<{baseName}> {VariableNames.Context};
        private readonly IInvocationContext<{interfaceName}> {VariableNames.ProtectedContext};

        public {className}(IInvocationContext<{baseName}> {VariableNames.Context}, IInvocationContext<{interfaceName}> {VariableNames.ProtectedContext})
        {{
            this.{VariableNames.Context} = {VariableNames.Context};
            this.{VariableNames.ProtectedContext} = {VariableNames.ProtectedContext};
        }}

        {string.Join("\r\n        ", members.Select(i => i.Accept(symbolVisitor)).SkipWhile(i => string.IsNullOrWhiteSpace(i)))}
    }}
}}

namespace LightMock.Generator
{{
    public static partial class MockExtensions
    {{

        // generated for abstract class 

        [DebuggerStepThrough]
        public static MockContext<{@namespace}.{@interfaceName}> GetProtectedContext(this Mock<{baseName}> @this)
            => (MockContext<{@namespace}.{@interfaceName}>)@this.ProtectedContext;

        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.Arrange(Expression{{Action{{TMock}}}})""/>
        /// </summary>
        [DebuggerStepThrough]
        public static Arrangement ProtectedArrange(this Mock<{baseName}> @this, Expression<Action<{@namespace}.{interfaceName}>> matchExpression)
            => @this.GetProtectedContext().Arrange(matchExpression);

        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.Arrange{{TResult}}(Expression{{Func{{TMock, TResult}}}})""/>
        /// </summary>
        [DebuggerStepThrough]
        public static Arrangement<TResult> ProtectedArrange<TResult>(this Mock<{baseName}> @this, Expression<Func<{@namespace}.{interfaceName}, TResult>> matchExpression)
            => @this.GetProtectedContext().Arrange(matchExpression);

        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.ArrangeProperty{{TResult}}(Expression{{Func{{TMock, TResult}}}})""/>
        /// </summary>
        [DebuggerStepThrough]
        public static PropertyArrangement<TResult> ProtectedArrangeProperty<TResult>(this Mock<{baseName}> @this, Expression<Func<{@namespace}.{interfaceName}, TResult>> matchExpression)
            => @this.GetProtectedContext().ArrangeProperty(matchExpression);


        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.Assert(Expression{{Action{{TMock}}}})""/>
        /// </summary>
        [DebuggerStepThrough]
        public static void ProtectedAssert(this Mock<{baseName}> @this, Expression<Action<{@namespace}.{interfaceName}>> matchExpression)
            => @this.GetProtectedContext().Assert(matchExpression);

        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.Assert(Expression{{Action{{TMock}}}}, Invoked)""/>
        /// </summary>
        [DebuggerStepThrough]
        public static void ProtectedAssert(this Mock<{baseName}> @this, Expression<Action<{@namespace}.{interfaceName}>> matchExpression, Invoked invoked)
            => @this.GetProtectedContext().Assert(matchExpression, invoked);

        // end generated for abstract class
    }}
}}
";
            return SourceText.From(code, Encoding.UTF8);
        }

        public override IEnumerable<Diagnostic> GetErrors() => Enumerable.Empty<Diagnostic>();

        public override IEnumerable<Diagnostic> GetWarnings() => Enumerable.Empty<Diagnostic>();

        public override void DoGeneratePart_CreateMockInstance(StringBuilder here)
        {
            here.Append($@"if (contextType == typeof({baseName})) return (T)(object)new {@namespace}.{className}((MockContext<{baseName}>)(object)this, (MockContext<{@namespace}.{interfaceName}>)ProtectedContext);");
        }

        public override void DoGeneratePart_CreateProtectedContext(StringBuilder here)
        {
            here.Append($@"if (contextType == typeof({baseName})) return new MockContext<{@namespace}.{interfaceName}>();");
        }

        public override string FileName => "Mock_" + base.FileName;
    }
}
