using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LightMock.Generator
{
    sealed class MockAbstractClassProcessor : ClassProcessor
    {
        private readonly SymbolVisitor<string> protectedVisitor;
        private readonly string @namespace;
        private readonly SymbolVisitor<string> symbolVisitor;
        private readonly string baseName;
        private readonly string className;
        private readonly string interfaceName;
        private readonly string typeArgumentsWithBrackets;
        private readonly object typeArgumentsWithComma;
        private readonly string whereClause;
        private readonly string commaArguments;
        private readonly List<string> constructors;
        private readonly List<string> constructorsCall;

        public MockAbstractClassProcessor(
            INamedTypeSymbol typeSymbol) : base(typeSymbol)
        {

            this.protectedVisitor = new ProtectedMemberSymbolVisitor();
            this.@namespace = typeSymbol.ContainingNamespace.ToDisplayString(KNamespaceDisplayFormat);
            this.symbolVisitor = new AbstractClassSymbolVisitor(@namespace);
            this.baseName = typeSymbol.OriginalDefinition.Name;
            this.className = Prefix.MockClass + typeSymbol.Name;
            this.interfaceName = Prefix.ProtectedToPublicInterface + typeSymbol.Name;

            var to = typeSymbol.OriginalDefinition;
            var withTypeParams = to.ToDisplayString(KWithTypeParams);
            var withWhereClause = to.ToDisplayString(KWithWhereClause);
            var typeArguments = withTypeParams.Replace(to.ToDisplayString(KNamespaceDisplayFormat), "");

            this.typeArgumentsWithBrackets = typeArguments.Length > 0 ? typeArguments : "";
            this.typeArgumentsWithComma = typeArguments.Length > 0 ? typeArguments.Trim('<', '>') + ", " : "";
            this.whereClause = withWhereClause.Replace(withTypeParams, "");
            this.commaArguments = string.Join(",", typeSymbol.OriginalDefinition.TypeArguments.Select(i => " "));
            this.constructors = new List<string>(
                to.Constructors.Select(
                    i => i.ToDisplayString(KConstructorFormat).Replace(typeSymbol.Name, "").Trim('(', ')')));
            this.constructorsCall = new List<string>(
                to.Constructors.Select(
                    i => i.ToDisplayString(KConstructorCallFormat).Replace(typeSymbol.Name, "").Trim('(', ')')));
        }

        string GenerateConstructor(string declaration, string call)
        {
            return $@"
        public {className}(IInvocationContext<{baseName}{typeArgumentsWithBrackets}> {VariableNames.Context}, IInvocationContext<{interfaceName}{typeArgumentsWithBrackets}> {VariableNames.ProtectedContext}, {declaration})
            : base({call})
        {{
            this.{VariableNames.Context} = {VariableNames.Context};
            this.{VariableNames.ProtectedContext} = {VariableNames.ProtectedContext};
        }}
";
        }

        string GenerateDefaultConstructor()
        {
            return $@"
        public {className}(IInvocationContext<{baseName}{typeArgumentsWithBrackets}> {VariableNames.Context}, IInvocationContext<{interfaceName}{typeArgumentsWithBrackets}> {VariableNames.ProtectedContext})
        {{
            this.{VariableNames.Context} = {VariableNames.Context};
            this.{VariableNames.ProtectedContext} = {VariableNames.ProtectedContext};
        }}
";
        }

        IEnumerable<string> GenerateConstructors()
        {
            for (int i = 0; i < constructors.Count; i++)
            {
                yield return constructors[i].Length == 0
                    ? GenerateDefaultConstructor()
                    : GenerateConstructor(constructors[i], constructorsCall[i]);
            }
        }

        public override SourceText DoGenerate()
        {
            var members = typeSymbol.GetMembers();
            var code = $@"// <auto-generated />
using LightMock;
using System;
using System.Diagnostics;
using System.Linq.Expressions;

namespace {@namespace}
{{
    public interface {interfaceName}{typeArgumentsWithBrackets}
        {whereClause}
    {{
        {string.Join("\r\n        ", members.Select(i => i.OriginalDefinition.Accept(protectedVisitor)).SkipWhile(i => string.IsNullOrWhiteSpace(i)))}
    }}


    partial class {className}{typeArgumentsWithBrackets} : {baseName}{typeArgumentsWithBrackets}, {interfaceName}{typeArgumentsWithBrackets}
        {whereClause}
    {{
        private readonly IInvocationContext<{baseName}{typeArgumentsWithBrackets}> {VariableNames.Context};
        private readonly IInvocationContext<{interfaceName}{typeArgumentsWithBrackets}> {VariableNames.ProtectedContext};

{string.Join("\r\n", GenerateConstructors())}

        {string.Join("\r\n        ", members.Select(i => i.OriginalDefinition.Accept(symbolVisitor)).SkipWhile(i => string.IsNullOrWhiteSpace(i)))}
    }}
}}

namespace LightMock.Generator
{{
    using {@namespace};

    public static partial class MockExtensions
    {{
        [DebuggerStepThrough]
        public static MockContext<{@namespace}.{@interfaceName}{typeArgumentsWithBrackets}> GetProtectedContext{typeArgumentsWithBrackets}(this Mock<{baseName}{typeArgumentsWithBrackets}> @this)
            {whereClause}
            => (MockContext<{@namespace}.{@interfaceName}{typeArgumentsWithBrackets}>)@this.ProtectedContext;

        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.Arrange(Expression{{Action{{TMock}}}})""/>
        /// </summary>
        [DebuggerStepThrough]
        public static Arrangement ProtectedArrange{typeArgumentsWithBrackets}(this Mock<{baseName}{typeArgumentsWithBrackets}> @this, Expression<Action<{@namespace}.{interfaceName}{typeArgumentsWithBrackets}>> matchExpression)
            {whereClause}
            => @this.GetProtectedContext().Arrange(matchExpression);

        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.Arrange{{TResult}}(Expression{{Func{{TMock, TResult}}}})""/>
        /// </summary>
        [DebuggerStepThrough]
        public static Arrangement<{VariableNames.MockTResult}> ProtectedArrange<{typeArgumentsWithComma}{VariableNames.MockTResult}>(this Mock<{baseName}{typeArgumentsWithBrackets}> @this, Expression<Func<{@namespace}.{interfaceName}{typeArgumentsWithBrackets}, {VariableNames.MockTResult}>> matchExpression)
            {whereClause}
            => @this.GetProtectedContext().Arrange(matchExpression);

        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.ArrangeProperty{{TResult}}(Expression{{Func{{TMock, TResult}}}})""/>
        /// </summary>
        [DebuggerStepThrough]
        public static PropertyArrangement<{VariableNames.MockTResult}> ProtectedArrangeProperty<{typeArgumentsWithComma}{VariableNames.MockTResult}>(this Mock<{baseName}{typeArgumentsWithBrackets}> @this, Expression<Func<{@namespace}.{interfaceName}{typeArgumentsWithBrackets}, {VariableNames.MockTResult}>> matchExpression)
            {whereClause}
            => @this.GetProtectedContext().ArrangeProperty(matchExpression);


        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.Assert(Expression{{Action{{TMock}}}})""/>
        /// </summary>
        [DebuggerStepThrough]
        public static void ProtectedAssert{typeArgumentsWithBrackets}(this Mock<{baseName}{typeArgumentsWithBrackets}> @this, Expression<Action<{@namespace}.{interfaceName}{typeArgumentsWithBrackets}>> matchExpression)
            {whereClause}
            => @this.GetProtectedContext().Assert(matchExpression);

        /// <summary>
        /// Shortcut for <see cref=""MockContext{{TMock}}.Assert(Expression{{Action{{TMock}}}}, Invoked)""/>
        /// </summary>
        [DebuggerStepThrough]
        public static void ProtectedAssert{typeArgumentsWithBrackets}(this Mock<{baseName}{typeArgumentsWithBrackets}> @this, Expression<Action<{@namespace}.{interfaceName}{typeArgumentsWithBrackets}>> matchExpression, Invoked invoked)
            {whereClause}
            => @this.GetProtectedContext().Assert(matchExpression, invoked);
    }}
}}
";
            return SourceText.From(code, Encoding.UTF8);
        }

        public override IEnumerable<Diagnostic> GetErrors() => Enumerable.Empty<Diagnostic>();

        public override IEnumerable<Diagnostic> GetWarnings() => Enumerable.Empty<Diagnostic>();

        public override void DoGeneratePart_GetInstanceType(StringBuilder here)
        {
            var toAppend = typeSymbol.IsGenericType
                ? $"if (gtd == typeof({@namespace}.{baseName}<{commaArguments}>)) return typeof({@namespace}.{className}<{commaArguments}>).MakeGenericType(contextType.GetGenericArguments());"
                : $"if (contextType == typeof({@namespace}.{baseName})) return typeof({@namespace}.{className});";
            here.Append(toAppend);
        }

        public override void DoGeneratePart_GetProtectedContextType(StringBuilder here)
        {
            var toAppend = typeSymbol.IsGenericType
                ? $@"if (gtd == typeof({@namespace}.{baseName}<{commaArguments}>)) return MockDefaults.MockContextType.MakeGenericType(typeof({@namespace}.{interfaceName}<{commaArguments}>).MakeGenericType(contextType.GetGenericArguments()));"
                : $@"if (contextType == typeof({@namespace}.{baseName})) return MockDefaults.MockContextType.MakeGenericType(typeof({@namespace}.{interfaceName}));";
            here.Append(toAppend);
        }

        public override string FileName => Prefix.MockClass + base.FileName;
    }
}
