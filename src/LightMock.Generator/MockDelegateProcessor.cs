using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LightMock.Generator
{
    sealed class MockDelegateProcessor : ClassProcessor
    {
        private readonly string fullName;
        private readonly string @namespace;

        public MockDelegateProcessor(INamedTypeSymbol typeSymbol) : base(typeSymbol)
        {
            this.fullName = typeSymbol.ToDisplayString(SymbolDisplayFormats.Namespace);
            this.@namespace = typeSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormats.Namespace);
        }

        public override SourceText DoGenerate()
        {

            var code = $@"// <auto-generated />
using LightMock;

namespace {@namespace}
{{
    sealed class {Prefix.MockClass}{typeSymbol.Name}
    {{
        private readonly IInvocationContext<{fullName}> {VariableNames.Context};

        public {Prefix.MockClass}{typeSymbol.Name}(IInvocationContext<{fullName}> {VariableNames.Context}, object unused1 = null, object unused2 = null)
        {{
            this.{VariableNames.Context} = {VariableNames.Context};
        }}

        public void Invoke({string.Join(", ", GetParametersWithTypeNames())})
        {{
            {VariableNames.Context}.Invoke(f => f.Invoke({string.Join(", ", GetParameters())}));
        }}
    }}
}}
";
            return SourceText.From(code, Encoding.UTF8);
        }

        IEnumerable<string> GetParametersWithTypeNames()
        {
            var dim = typeSymbol.DelegateInvokeMethod;
            if (dim != null)
            {
                foreach (var i in dim.Parameters)
                {
                    yield return i.Type.ToDisplayString(SymbolDisplayFormats.Namespace) + " " + i.Name;
                }
            }
        }

        IEnumerable<string> GetParameters()
        {
            var dim = typeSymbol.DelegateInvokeMethod;
            if (dim != null)
            {
                foreach (var i in dim.Parameters)
                {
                    yield return i.Name;
                }
            }
        }

        public override IEnumerable<Diagnostic> GetErrors()
            => Enumerable.Empty<Diagnostic>();

        public override IEnumerable<Diagnostic> GetWarnings()
            => Enumerable.Empty<Diagnostic>();

        public override void DoGeneratePart_GetInstanceType(StringBuilder here)
        {
            //var toAppend = typeSymbol.IsGenericType
            //    ? $"if (gtd == typeof(global::{@namespace}.{interfaceName}<{commaArguments}>)) return typeof(global::{@namespace}.{className}<{commaArguments}>).MakeGenericType(contextType.GetGenericArguments());"
            //    : $"if (contextType == typeof(global::{@namespace}.{interfaceName})) return typeof(global::{@namespace}.{className});";
            var toAppend = $"if (contextType == typeof(global::{fullName})) return typeof(global::{fullName});";
            here.Append(toAppend);
        }

        public override void DoGeneratePart_GetDelegate(StringBuilder here)
        {
            var toAppend = $@"if (contextType == typeof(global::{fullName}))
{{
    global::{fullName} result = new global::{@namespace}.{Prefix.MockClass}{typeSymbol.Name}((IInvocationContext<global::{fullName}>)mockContext).Invoke;
    return result;
}}";
            here.Append(toAppend);
        }
    }
}
